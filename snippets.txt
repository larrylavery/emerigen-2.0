Environment:
Couchbase Server: 6.5
Java SDK: 3.0
Java language level: 2.11

Description: Receiving intermittent "upsert" and "insert" errors during the execution 
of a large suite (300) of automated test cases. Errors do NOT occur when the failing 
test cases are executed individually. Any assistance is appreciated. Error text:
-------------------------------------------------------------
query exception, cause: com.couchbase.client.core.error.Requ
estCanceledException: InsertRequest {"cancelled":true,"completed":true,"coreId":1,"idempotent":false,"reason":"SHUTDOWN"
,"requestId":56,"requestType":"InsertRequest","retried":0,"service":{"bucket":"knowledge","collection":"_default","docum
entId":"211120220017","opaque":"0x42","scope":"_default","syncDurability":{"empty":true,"present":false},"type":"kv"},"t
imeoutMs":5000,"timings":{"encodingMicros":158,"totalMicros":1690}
--------------------------------------------------------------
query exception, cause: com.couchbase.client.core.error.Requ
estCanceledException: UpsertRequest {"cancelled":true,"completed":true,"coreId":1,"idempotent":false,"reason":"SHUTDOWN"
,"requestId":810,"requestType":"UpsertRequest","retried":0,"service":{"bucket":"knowledge","collection":"_default","docu
mentId":"50c893d0-816a-4079-9373-9a2328b653f2","opaque":"0x1ff","scope":"_default","syncDurability":{"empty":false,"pres
ent":true},"type":"kv"},"timeoutMs":10000,"timings":{"encodingMicros":87,"totalMicros":251}}





Testing exceptions
		final Throwable throwable = catchThrowable(
				() -> CouchbaseRepository.getInstance());

		// Then
		then(throwable).as(
				"A ConfigurationException or TimeoutException should be thrown if a bad connectionString is passed")
				.isInstanceOf(RuntimeException.class);

// TODO Decode the content of the document into an instance of the target class.
// List<String> strings = result.contentAs(new TypeRef<List<String>>(){});
// return getResult.contentAs(new TypeRef<SensorEvent>() {
// getResult.contentAs(SensorEvent.class);
// getResult.contentAs(clazz.class);


Get count

		List<JsonObject> jsonObjects = result.rowsAsObject();
		int count = jsonObjects.get(0).getInt("$1");

		
get results

		List<JsonObject> jsonObjects = result.rowsAsObject();

		for (JsonObject value : queryResult.rowsAsObject()) {

		}	

		// Create predicted sensorEvent json document
		JsonArray jsonArray2 = JsonArray.create();
		for (int i = 0; i < predictedSensorEvent.getValues().length; i++) {
			jsonArray2.add(predictedSensorEvent.getValues()[i]);
		}
		

// List<String> strings = result.contentAs(new TypeRef<List<String>>(){});
// return getResult.contentAs(new TypeRef<SensorEvent>() {
// getResult.contentAs(SensorEvent.class);
// getResult.contentAs(clazz.class);


		// Register custom deserializer
//		SimpleModule module = new SimpleModule("CustomCycleDeserializer",
//				new Version(1, 0, 0, null, null, null));
//		module.addDeserializer(Cycle.class, new CustomCycleDeserializer());
//		mapper.registerModule(module);


Sensor hrSensor = SensorManager.getInstance().getDefaultSensorForLocation(
		Sensor.TYPE_HEART_RATE, Sensor.LOCATION_PHONE);

Random rd = new Random(); // creating Random object
		float[] values = new float[] { rd.nextFloat(), rd.nextFloat() };
		SensorEvent event1 = new SensorEvent(hrSensor, values);
		float[] values2 = new float[] { rd.nextFloat() + 10, rd.nextFloat() + 10 };
		SensorEvent event2 = new SensorEvent(hrSensor, values2);
		float[] values3 = new float[] { rd.nextFloat() + 100, rd.nextFloat() + 100 };
		SensorEvent event3 = new SensorEvent(hrSensor, values3);
		float[] values4 = new float[] { rd.nextFloat() + 1000, rd.nextFloat() + 1000 };
		SensorEvent event4 = new SensorEvent(hrSensor, values4);
		float[] values5 = new float[] { rd.nextFloat()+10000, rd.nextFloat()+10000};
		SensorEvent event5 = new SensorEvent(hrSensor, values5);
